<!doctype html>
<html>
  <head> </head>
  <body>
    <div class="container" x-data="dataset">
      <h1>Snip</h1>
      <h2>Capture screen</h2>
      <div class="camera">
        <video
          id="video"
          class="video"
          x-ref="video"
          autoplay
          @play="videoOnLoad"
        >
        </video>
        <canvas
          class="canvas"
          id="cv1"
          x-ref="canvas"
          @click="initCanvas"
          @mousedown="mouseDownOnCanvas"
          @mousemove="mouseMoveOnCanvas"
          @mouseup="mouseUpOnCanvas"></canvas>
      </div>
      <div class="process-wrapper">
        <div class="process-image">
          <h2>Image</h2>
          <img id="my_img" class="image" x-ref="captureImg" />
        </div>
        <div class="process-result">
          <h2>Result</h2>
          <div class="results" id="output" x-ref="output"></div>
        </div>
      </div>
      <h2>Options</h2>
      <div class="options">
        <label for="automode">
          <input
            type="checkbox"
            id="automode"
            name="automode"
            disabled
            checked="isAutoMode"
            @click="toggleAutoMode"
          />
          Auto Mode
        </label>

        <label for="showArea">
          <input
            type="checkbox"
            id="showArea"
            name="showArea"
            checked="isShowArea"
            @click="toggleShowArea"
          />
          Show Area
        </label>

        <label for="preprocess">
          <input
            type="checkbox"
            id="preprocess"
            name="preprocess"
            checked="isPreprocess"
            @click="togglePreprocess"
          />
          Preprocess Image
        </label>
        <label for="showImage">
          <input
            type="checkbox"
            id="showImage"
            name="showImage"
            checked="isShowImage"
            @click="toggleShowImage"
          />
          Show Image
        </label>
      </div>
    </div>
    <div id="hint" style="margin-top: 10px">
      Draw on the stream above to select the text area.
    </div>
  </body>
</html>

<style>
  h1 {
    @apply text-4xl font-bold text-primary;
  }

  h2 {
    @apply text-primary-content text-2xl font-bold pt-2;
  }
  .camera {
    @apply relative basis-2/3;
  }
  .video {
    @apply w-full min-h-60;
  }
  .canvas {
    @apply absolute top-0 left-0 w-full h-full z-10 cursor-pointer border border-primary-content;
  }
  .options {
    @apply p-2 border border-primary-content;
  }
  .results {
    @apply p-2 border border-primary-content flex-1 overflow-auto;
  }
  .process-wrapper {
    @apply flex items-stretch min-h-60;
  }
  .process-image {
    @apply flex-1;
  }
  .process-result {
    @apply flex-1 flex flex-col;
  }
</style>

<script>
  import {
    blurARGB,
    dilate,
    invertColors,
    thresholdFilter,
  } from "@scripts/image-processing";
  import Alpine from "alpinejs";
  import { createWorker } from "tesseract.js";

  window.Alpine = Alpine;

  Alpine.data("dataset", () => ({
    videoLoaded: false,
    lastMouseY: 0,
    lastMouseX: 0,
    canvasX: 0,
    canvasY: 0,
    mouseX: 0,
    mouseY: 0,
    mouseDown: false,
    rect: {},
    imageData: null,
    //* Elements
    video: null,
    canvas: null,
    output: null,
    captureImg: null,
    ctx: null,
    //* Image processing properties
    radius: 1,
    level: 0.5,
    //* Options
    isPreprocess: true,
    isShowImage: true,
    isShowArea: true,

    init() {
      this.video = this.$refs.video;
      this.canvas = this.$refs.canvas;
      this.output = this.$refs.output;
      this.captureImg = this.$refs.captureImg;
      this.canvasX = this.$refs.canvas.getBoundingClientRect().left;
      this.canvasY = this.$refs.canvas.getBoundingClientRect().top;
      this.ctx = this.$refs.canvas.getContext("2d");
    },

    async startCapture() {
      try {
        this.video.srcObject = await navigator.mediaDevices.getDisplayMedia({
          video: {
            // cursor: "always",
          },
          audio: false,
        });
      } catch (err) {
        console.error("Error" + err);
      }
    },

    initCanvas() {
      if (!this.videoLoaded) {
        this.startCapture();
      }
    },

    resizeCanvas(element) {
      this.canvas.width = element.offsetWidth;
      this.canvas.height = element.offsetHeight;
    },

    videoOnLoad(element) {
      this.videoLoaded = true;
      this.resizeCanvas(element.target);
    },

    recognizeImage(img) {
      (async () => {
        const worker = await createWorker("eng");

        await worker.setParameters({ preserve_interword_spaces: "1" });
        const {
          data: { text },
        } = await worker.recognize(img);
        console.log(text);
        // writeIntoHtml("Result: " + text);
        this.output.innerHTML = text;
        await worker.terminate();
      })();
    },

    showStuff({ width, height, x, y }) {
      const aspectRatioY = this.video.videoHeight / this.canvas.height;
      const aspectRatioX = this.video.videoWidth / this.canvas.width;

      const offsetY = 0.5 * aspectRatioY;

      let cv2 = document.createElement("canvas");
      cv2.width = width * aspectRatioX;
      cv2.height = height * aspectRatioY;
      let ctx2 = cv2.getContext("2d");
      if (!ctx2) return;

      ctx2.drawImage(
        this.video,
        x * aspectRatioX,
        (y + offsetY) * aspectRatioY,
        width * aspectRatioX,
        (height - offsetY) * aspectRatioY,
        0,
        0,
        cv2.width,
        cv2.height
      );

      if (this.isPreprocess) {
        ctx2.putImageData(this.preprocessImage(cv2), 0, 0);
      }
      this.imageData = cv2.toDataURL("image/jpg");
      if (this.isShowImage) {
        this.captureImg.hidden = false;
        this.captureImg.src = this.imageData;
      } else {
        this.captureImg.hidden = true;
      }
      this.recognizeImage(this.imageData);
    },

    preprocessImage(canvas) {
      const processedImageData = canvas
        .getContext("2d")
        .getImageData(0, 0, canvas.width, canvas.height);
      blurARGB(processedImageData.data, canvas, this.radius);
      dilate(processedImageData.data, canvas);
      invertColors(processedImageData.data);
      thresholdFilter(processedImageData.data, this.level);
      return processedImageData;
    },

    showLoadingOCR() {
      this.output.innerHTML = "Extracting text...";
    },

    mouseDownOnCanvas(e) {
      this.lastMouseX = e.clientX - this.canvasX;
      console.log("ðŸš€ ~ mouseDownOnCanvas ~ e.clientX:", e.clientX);
      this.lastMouseY = e.clientY - this.canvasY;
      console.log("ðŸš€ ~ mouseDownOnCanvas ~ e.clientY:", e.clientY);
      this.mouseDown = true;
    },

    mouseMoveOnCanvas(e) {
      this.mouseX = e.clientX - this.canvasX;
      this.mouseY = e.clientY - this.canvasY;

      if (this.mouseDown) {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); //clear canvas
        this.ctx.beginPath();
        let width = this.mouseX - this.lastMouseX;
        let height = this.mouseY - this.lastMouseY;
        this.ctx.rect(this.lastMouseX, this.lastMouseY, width, height);
        this.rect = { x: this.lastMouseX, y: this.lastMouseY, width, height };
        this.ctx.strokeStyle = "red";
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
      }
    },

    mouseUpOnCanvas() {
      this.mouseDown = false;

      if (this.rect.width > 0) {
        if (true) {
          console.log("its checked");
          // clearInterval();
          this.showLoadingOCR();
          setInterval(this.showStuff(this.rect), 500);
        } else {
          this.showLoadingOCR();
          this.showStuff(this.rect);
          this.hint.innerHTML = "Click on stream to refresh.";
        }
      }
    },

    toggleShowImage() {
      this.isShowImage = !this.isShowImage;
      if (this.isShowImage) {
        this.captureImg.hidden = false;
        this.captureImg.src = this.imageData;
      } else {
        this.captureImg.hidden = true;
      }
    },

    togglePreprocess() {
      this.isPreprocess = !this.isPreprocess;
      let preprocessIntevelId;
      if (this.isPreprocess) {
        preprocessIntevelId = setInterval(this.showStuff(this.rect), 500);
      } else {
        clearInterval(preprocessIntevelId);
      }
    },

    toggleShowArea() {
      this.isShowArea = !this.isShowArea;
      if (this.isShowArea) {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); //clear canvas
        this.ctx.beginPath();
        this.ctx.rect(
          this.rect.x,
          this.rect.y,
          this.rect.width,
          this.rect.height
        );
        this.ctx.strokeStyle = "red";
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
      } else if (this.rect.width > 0) {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); //clear canvas
      }
    },

    toggleAutoMode() {
      this.isAutoMode = !this.isAutoMode;
      let automodeIntevelId;
      if (this.isAutoMode) {
        automodeIntevelId = setInterval(this.showStuff(this.rect), 500);
      } else {
        clearInterval(automodeIntevelId);
      }
    },
  }));
</script>
