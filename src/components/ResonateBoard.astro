<div class="resonate relative" x-data="dataset">
  <canvas
    x-ref="canvas"
    class="border w-full h-full absolute top-0 left-0 bg-white/10 -z-10"
  ></canvas>

  <template x-for="row in boardRow">
    <div class="flex">
      <template x-for="col in boardCol">
        <div
          data-col="col"
          data-row="row"
          class="w-10 h-10 border"
          x-data="{ isDragOver: false }"
          :class="isDragOver ? 'bg-primary' : ''"
          @drop=""
          @dragover.prevent="isDragOver = true"
          @dragleave.prevent="isDragOver = false"
        >
        </div>
      </template>
    </div>
  </template>

  <div class="mt-10"></div>
  <div
    class="w-10 h-10 border"
    draggable="true"
    @drag="onDrag"
    @dragstart="onDragStart"
  >
  </div>
</div>

<script>
  import SAT from "sat";
  import Alpine from "alpinejs";

  window.Alpine = Alpine;

  const V = function (x, y) {
    return new SAT.Vector(x, y);
  };
  const P = function (pos, points) {
    return new SAT.Polygon(pos, points);
  };
  const C = function (pos, r) {
    return new SAT.Circle(pos, r);
  };
  const B = function (pos, w, h) {
    return new SAT.Box(pos, w, h);
  };

  Alpine.data("dataset", () => ({
    boardCol: 6,
    boardRow: 6,
    dragItem: null,
    dragPoly: null,
    canvas: null,
    ctx: null,

    init() {
      this.canvas = this.$refs.canvas;
      this.ctx = this.$refs.canvas.getContext("2d");
    },

    drawPoly(poly, fill) {
      if (!this.ctx) return;
      this.ctx.fillStyle = fill;

      this.ctx.beginPath();
      this.ctx.moveTo(poly.pos.x, poly.pos.y);
      poly.calcPoints.forEach((p) => {
        this.ctx.lineTo(poly.pos.x + p.x, poly.pos.y + p.y);
      });
      this.ctx.closePath();
      this.ctx.fill();
    },

    onDragStart(event) {
      this.canvas.width = this.canvas.offsetWidth;
      this.canvas.height = this.canvas.offsetHeight;
      this.dragItem = event.target;

      let rect = event.target.getBoundingClientRect();

      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); //clear canvas

      let poly1 = P(V(rect.left, rect.top), [
        V(0, 0),
        V(40, 0),
        V(40, 40),
        V(0, 40),
      ]);

      this.drawPoly(poly1, "rgba(255,0,0,1)");
    },

    onDrag(event) {},

    distanceBetween(point1, point2) {
      const dx = point2.x - point1.x;
      const dy = point2.y - point1.y;
      const dz = point2.z - point1.z;
      return Math.sqrt(dx * dx + dy * dy + dz * dz);
    },

    checkCollision(item, block) {
      // Your collision detection algorithm goes here
      // ...
      return true; // Collision detected
    },

    sweepAndPrune(item, blocks) {
      const sweepRadius = 42; // (slightly larger than the block size) is the maximum distance between the item's position and a block's position that is considered "close enough" to warrant a collision check
      const pruneRadius = 48; // (slightly larger than the sweepRadius) is the maximum distance between the item's position and a block's position that is considered "far enough" to warrant pruning the block from the search space

      for (const block of blocks) {
        const distance = this.distanceBetween(item.position, block.position);
        if (distance > sweepRadius) continue; // Prune blocks that are too far away

        const collision = this.checkCollision(item, block);
        if (collision) return true; // Collision detected, return true

        if (distance > pruneRadius) continue; // Prune blocks that are too far away
      }

      return false; // No collision detected
    },
  }));

  // let poly1 = P(V(160, 120), [
  //   V(0, 0),
  //   V(60, 0),
  //   V(100, 40),
  //   V(60, 80),
  //   V(0, 80),
  // ]);

  // let poly2 = P(V(200, 120), [
  //   V(0, 0),
  //   V(60, 0),
  //   V(100, 40),
  //   V(60, 80),
  //   V(0, 80),
  // ]);

  // let canvas = document.getElementById("c") as HTMLCanvasElement;
  // let canvasWidth = canvas?.width;
  // let canvasHeight = canvas?.height;
  // let ctx = canvas.getContext("2d");

  // function drawPoly(poly, fill) {
  //   if (!ctx) return;

  //   ctx.fillStyle = fill;
  //   ctx.beginPath();
  //   ctx.moveTo(poly.pos.x, poly.pos.y);
  //   poly.calcPoints.forEach(function (p) {
  //     ctx?.lineTo(poly.pos.x + p.x, poly.pos.y + p.y);
  //   });
  //   ctx.closePath();
  //   ctx.fill();
  // }

  // // Draw the original polygon
  // drawPoly(poly1, "rgba(255,0,0,1)");
  // // Draw it again
  // drawPoly(poly2, "rgba(0,255,0,0.5)");

  // let response = new SAT.Response();
  // let collided = SAT.testPolygonPolygon(poly1, poly2, response);
  // console.log("ðŸš€ ~ collided:", collided);
</script>
